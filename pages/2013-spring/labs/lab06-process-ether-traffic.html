<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <title>CSCI 363 &mdash; Computer Networks -- Labs</title>
  <meta http-equiv="content-type" content="text/html; charset=us-ascii">
  <link rel="stylesheet" type="text/css" href=
  "http://www.eg.bucknell.edu/~cs363/common-files/course.css">
  <base href="http://www.eg.bucknell.edu/~cs363/2013-spring/">
  <script type = "text/javascript" language = "JavaScript" src ="/~cs363/common-files/courseinfo.js">
</script>
</head>

<body>
<!-- header starts -->
<div id = "header">
<script type = "text/javascript" language = "JavaScript">
insertHTML('/~cs363/common-files/cs363header.html', 'header');
</script>
</div>
<!-- header ends -->

<h2>Lab 06: Processing Captured Network Traffic</h2>

<h4>Goals</h4>

<ul>
 <li> <font color=red><b>Understand how encapsulation takes place in the Internet protocol stack:</b></font> We have discussed layered architecture of network protocols in class and read about it in various sources, but seeing it first hand in captured network traffic will take your understanding to a deeper level.</li>

 <li> <font color = red><b>Learn to work with Ethernet frames captured by the Linux Wireshark application:</b></font> Recognize the frame type, interpret Ethernet hardware (MAC) address, parse the various fields in an IP packet (such senders and receivers IP addresses).</li>
</ul>

<h4>Credits</h4>

<p>The material for this lab was created by Professor L. Felipe Perrone based on previous work by Professors Xiannong Meng (Bucknell University) and Ralph Droms (Cisco). Permission to reuse this material in parts or in its entirety is granted provided that the credits note is not removed. Additional students files associated with this lab, as well as any existing solutions can be provided upon request by e-mail to <em>perrone[at]bucknell[dot]edu</em>.</p>

<h4>Setup</h4>

<p>Copy all files for this lab by doing the following.</p>

<p><font color=red><b>cp -r ~cs363/Spring13/student/labs/lab06 .</b></font></p>

<p>Then add the newly copied <code>lab06</code> to your <em>gitlab</em> repository.</p>

<h4>Background</h4>

<p><b>The format of the packet traces</b></p>

<p>Packet trace files are binary files, unless someone has kindly parsed their contents and converted all the information to human-understandable text. If you have ever tried to <b>cat</b> a binary file to your terminal, you know what kind of mess you get. (You end up having to reset the terminal with <b>/usr/bin/reset</b>, in Linux, or alternatively, you may kill the terminal and open another one.) The proper way to examine the contents of a binary file is to use an editor that supports that kind of format or, instead, use some kind of utility that converts each group of 4 bits (what is sometimes called a <em>nibble</em>) into a hexadecimal digit. By now you may have used the Linux hex-dump utility <b>xxd</b> several times (if you haven't, check out its <em>man</em> page.)</p>

<p>The directory for this lab, located at <code>~cs363/Spring13/student/labs/lab06</code> contains a trace file called <code>dec21.dat</code> which was generated by Wireshark in Dana. We will work with this file to explain what you will accomplish in this lab. Later on, after you have written your new application for analyzing frames, you can try your program in other trace files generated by the textbook authors in the directory of <code>~cs363/traces/</code>.</p>

<p>Try to view the contents of <code>dec21.dat</code> with <b>xxd</b>. Note that <b>xxd</b> is nice enough to display on the right of hex-dump, the interpretation of the same binary data as ASCII text. This makes it particularly easy for a human to spot any occurrence of text within the binary file. The first column contains a byte-address relative to the beginning of the file; this address is displayed in hexadecimal and advances in increments of 16 from line to line. The next four columns correspond to a group of 16 consecutive bytes in the binary file (remember that each two hexadecimal digits correspond to one byte.) The last column, all the way on the right, show the ASCII representation of those 16 bytes. If one byte value does not correspond to any printable ASCII character, it is displayed as a '.', that is, a period. Note that this hex-dump produced by <b>xxd<</b> makes it particularly easy for a human to spot any occurrence of text within a binary file.</p>

<p>Try the following command at your terminal.</p>

<p><font color=red><b>xxd ~cs363/Spring13/student/labs/lab06/dec21.dat | less</b></font></p>

<p>What you see should correspond to:</p>

<pre>
0000000: d4c3 b2a1 0200 0400 0000 0000 0000 0000 ................
0000010: ffff 0000 0100 0000 47c5 a943 fd14 0300 ........G..C....
0000020: 2a00 0000 2a00 0000 ffff ffff ffff 0001 *...*...........
0000030: 039c ffbd 0806 0001 0800 0604 0001 0001 ................
0000040: 039c ffbd c0a8 0166 0000 0000 0000 c0a8 .......f........
0000050: 0101 49c5 a943 5eed 0d00 4000 0000 4000 ..I..C^...@...@.
0000060: 0000 0001 039c ffbd 000c 41a1 f5da 0806 ..........A.....
0000070: 0001 0800 0604 0002 000c 41a1 f5da c0a8 ..........A.....
.
.
.
</pre>

<p>The format of this data file is the <em>libpcap</em> standard. Follow <a href = "http://wiki.wireshark.org/Development/LibpcapFileFormat">this link</a> to find information for developers at the <em>Wireshark</em> project website. Instead of duplicating information from the project site here, we just ask you to get the instructions on how to understand the file from the project's website. The basic idea is that the file starts out with a global header, which is followed by a sequence of tuples <em>&lt;captured packet header, packet data&gt;</em>.</p>

<p>The key is to understand the structure of a captured packet file, which is represented in the follogin graphics (from <a href = "http://wiki.wireshark.org/Development/LibpcapFileFormat">http://wiki.wireshark.org/Development/LibpcapFileFormat</a>)</p>

<font size=-1>
<table>
<tbody><tr>  <td style="background-color: #ffc0c0"><p class="line862"> Global Header </td>
  <td style="background-color: #c0ffc0"><p class="line862"> Packet Header </td>
  <td style="background-color: #c0ffc0"><p class="line862"> Packet Data </td>
  <td style="background-color: #c0c0ff"><p class="line862"> Packet Header </td>
  <td style="background-color: #c0c0ff"><p class="line862"> Packet Data </td>
  <td style="background-color: #e0c0c0"><p class="line862"> Packet Header </td>
  <td style="background-color: #e0c0c0"><p class="line862"> Packet Data </td>
  <td><p class="line862"> ... </td>
</tr>
</tbody>
</table>
</font>

<p>The <em>Global Header</em> structure is defined in the include file <em>/usr/include/pcap/pcap.h</em> which is extracted as follows.</p>

<textarea rows = 10 cols = 80>
struct pcap_file_header {
	bpf_u_int32 magic;
	u_short version_major;
	u_short version_minor;
	bpf_int32 thiszone;	/* gmt to local correction */
	bpf_u_int32 sigfigs;	/* accuracy of timestamps */
	bpf_u_int32 snaplen;	/* max length saved portion of each pkt */
	bpf_u_int32 linktype;	/* data link type (LINKTYPE_*) */
};
</textarea>

<p>The <em>Packet Header</em> structure is also defined in the include file <em>/usr/include/pcap/pcap.h</em> which is extracted as follows.</p>

<textarea rows = 8 cols = 80>
struct pcap_pkthdr {
        bpf_u_int32 tv_sec;     /* time when the packet was captured */
        bpf_u_int32 tv_usec;    /* sec and u sec reading */
	bpf_u_int32 caplen;	/* length of portion present */
	bpf_u_int32 len;	/* length this packet (off wire) */
};
</textarea>

<p>The type definition of <em>bpf_u_int32</em> in both header files is just an unsiged 32-bit integer.</p>

<p>The packet data, for our purposes in this lab, will be an Ethernet frame, which is structured as in the figure below.</p>

<p><img src = "labs/ether-300x56.png" alt = "Ethernet frame format"></p>

<p>The preamble of the frame contains a fixed bit pattern that is used to mark the beginning of the frame during transmission. It is important to note that this preamble is used by Layer 2 to identify frame boundaries. <em><font color=red>The preamble is not part of the data captured for each frame.</font></em></p>

<p>The Ethernet destination and the source addresses are each a 48-bit long value. (Note that they are not IP addresses.) These values are stored in binary in the frame, obviously, but in order to make them more human-friendly, they are normally written as the hexadecimal representation of 6 bytes separated by colons as in:</p>

<pre>
00:0A:B7:4C:C1:33
</pre>

<p>One needs to determine the type of the protocol that generated the body of the Ethernet frame in order to understand this data; which is the 16-bit <em>type</em> field in the header. The values in this field were standardized. A commonly used collection can be found at <a href = "http://en.wikipedia.org/wiki/EtherType">&lt;http://en.wikipedia.org/wiki/EtherType&gt;</a>, and a complete list can be found at <a href = "http://www.cavebear.com/archive/cavebear/Ethernet/type.html">&lt;http://www.cavebear.com/archive/cavebear/Ethernet/type.html&gt;</a>.</p>

<p>The body of the frame contains the data in which we are interested, that is, the packet pushed down from protocols higher up in the protocol stack.</p>

<p>The CRC is used only for error detection by the Layer 2 protocol. This field isn't terribly interesting to one who captures frames for posterior analysis because after all, who would be interested in studying a corrupted frame? <em><font color=red>The CRC is not part of the data captured for each frame.</font></em></p>

<p>The data structures you will need to use in this assignment have already been defined in an include file in the Linux system. Look at <font color=red>/usr/include/pcap.h</font> to find the definition of the following types among others:</p>

<pre>
pcap_file_header // a struct for the global file header
pcap_pkthdr // a struct for individual packet headers
</pre>

<p>If you read this header file carefully, you will notice that the library <b>libpcap</b> defines a number of functions, which can be useful to you in this or in future assignments. Use your best resources to find documentation on these functions to understand what they do. The first resource to try are the manual pages; try doing <b>man pcap</b>. Though the <b>libpcap</b> contains a number of useful functions, we don't have to use the library. Instead, we can define our own functions, as long as we follow the structure of the captured traffic file, which is defined in <code>pcap.h</code>.</p>

<p>Other header files that may define data types that will be useful to you are listed below. You should browse them before you attempt to redefine a data type that is already defined in these standard header files.</p>

<font color=red><b>
<ul>
  <li> <code>/usr/include/netinet/if_ether.h</code></li>
  <li> <code>/usr/include/net/ethernet.h</code></li>
  <li> <code>/usr/include/net/if_arp.h</code></li>
</ul></b></font>

<h4>Parsing a packet trace</h4>

<p>You are being given the skeleton of a C program to analyze, that is,to parse a packet trace. The file is called <code>etherTrace.c</code> and needs to be copied from <code>~cs363/Spring13/labs/lab06</code> along with other files. Note that there is almost nothing implemented in this file; it contains only type definitions and guidelines on how to flesh it out into a full program. Read it carefully before you proceed.</p>

<p>You will expand this skeleton program into a complete C program that prints the frame length as received (<code>caplen</code> in the packet trace header), the arrival time of each frame, the source and destination Ethernet address, and the protocol type.</p>

<h4>Reporting a frames arrival time</h4>

<p>When we report the captured time of a frame, use the <code>ts</code> field in the <code>pcaprec_hdr_s</code> structure. The <code>ts</code> field has a type of <code>struct timeval</code>, which we have used in our previous labs. The values in the <code>ts</code> structure was recorded at the time of frame capture using the system call <code>gettimeofday()</code>. If you don't remember how they work, check them out using the Linux manual pages on the subject of <em>gettimeofday()</em> and <em>ctime()</em>. The printed time should be in a string format, as generated by the function <em>ctime()</em> as follows,<p>

<p><em>Wed Dec 21 16:12:39 2005</em></p>

<h4>Reporting Ethernet addresses</h4>

<p>Ethernet, or MAC, addresses are 48 bits (6 bytes) long. You could come up with several different ways to transform the 48-bits address in binary into a printable string of hexadecimal numbers, but there is a standard way to accomplish such a feat. Read the manual page for the library function <code>ether_ntoa</code> to discover that it is exactly what you need to convert 48 bits in network byte order to a string in the standard hex-digits-and-colons notation (which omits leading zeros, if there are any). Note that you should copy the string returned by this function into your own buffer; since what is returned is a pointer to a statically allocated buffer, subsequent calls to the same function will overwrite it.</p>

<p>Alternatively, you could use the following function to convert the Ethernet address into a readable character string.</p>

<textarea rows = 25 cols = 80>
/*
 * Convert ether address to a readable format. Ethernet address
 * is six bytes long.
 * Use this function if your systems' 'ether_ntoa()' doesn't work.
 */
char * ether_addr_to_string(char *host_addr) {

  char * retval = (char*)malloc(BUFSIZE+1);
  sprintf(retval, "%02x:%02x:%02x:%02x:%02x:%02x",
	  (u_char)(host_addr[0]),
	  (u_char)host_addr[1],
	  (u_char)host_addr[2],
	  (u_char)host_addr[3],
	  (u_char)host_addr[4],
	  (u_char)host_addr[5]);

  if (strlen(retval) >= BUFSIZE)
    retval[BUFSIZE] = 0; // terminate the string
  return retval;
}
</textarea>

<h4>Reading binary files</h4>

<p>The key to read any binary file is to be able to figure out the length of the appropriate chunk to read, read the data into a byte buffer (an array of unsigned char), and then cast what is read into the appropriate format. For example, if one knows the structure of the file is an Ethernet frame that has a header of the type <code>struct cap_frame_header_t</code>, then one can read the frame and align the frame with Ethernet header using the following statements.</p>

<textarea rows = 27 cols = 80>
/* The following structure is for the Wireshark capture file */
struct cap_frame_header_t {
     bpf_u_int32 tv_sec;     /* time when the packet was captured */
     bpf_u_int32 tv_usec;    /* sec and u sec reading */
     uint32 caplen;           // num of bytes captured
     uint32 len;              // actual num of bytes in packet
} frame_header;

...
/* 
 * read from the 'ifile' 'frame_header.caplen' number of bytes
 * into 'pktbuf'
 */
size_read = read (ifile, pktbuf, frame_header.caplen);
...

/* 
 * now align the buffer with the ethernet header to access proper
 * fields, for example,
 * ethptr->ether_type    // ethernet frame type (2 bytes)
 * ethptr->ether_dhost   // ethernet destination address (6 bytes)
 * ethptr->ether_shost   // ethernet source address (6 bytes)
 */
ethptr = (struct ether_header *)pktbuf;
...
</textarea>

<h4>Access to information within a trace file</h4>

<p>The <em>Wireshark</em> captured network traffic data file consists of a collection of &lt;frame-header, frame-data&gt; following a fixed size file header as defined in <code>struct pcap_hdr_s</code>. Each of the <em>frame header</em> has the format defined in <code>struct pcaprec_hdr_s</code>, while the <em>frame data</em> contains the actual Ethernet frame header and a portion of the payload (e.g., an IP header followed by a TCP header). The definitions of both header files can be seen in <code>/usr/include/pcap/pcap.h</code>, or in the program skeleton you copied (or about to copy) in <code>etherTrace.c</code>. To read the trace file, one would have to first read the file header, followed by a loop in which each cycle reads one frame header and one section of the frame data, as outlined in the program skeleton <code>etherTrace.c</code>. The amount of data to read as the file header is defined by the <code>sizeof(struct pcap_hdr_s)</code>. For each frame, the frame header size is defined by <code>sizeof(struct pcaprec_hdr_s)</code>, the amount of data in a frame can vary. The Ethernet header is defined as in <code>/usr/include/net/ethernet.h</code>. Once the data is aligned with an Ethernet header structure, one can access the information within the Ethernet header such as <code>ether_type</code>, <code>ether_dhost</code>, and <code>ether_shost</code>.</p>

<h4>Your work</h4>

<p>Complete the program <code>etherTrace.c</code> and run it on trace <code>~cs363/Spring13/student/labs/lab06/dec21.dat</code>. Your program should read the name of the trace file to work with as a command line parameter, then process the entire file including all frames included in the captured data file.</p>

<p>You will expand this skeleton program into a complete C program that prints the following pieces of information from the trace header.</p>

<ul>
  <li>The magic number of the file.</li>
  <li>The major version and minor version of the trace program.</li>
  <li>The maximum captured packet length.</li>
  <li>Link layer type.</li>
</ul>

<p>For each Ethernet frame in the trace, you are asked to report the following:</p>

<ul>
  <li>The time the packet is captured.</li>
  <li>The number of bytes captured.</li>
  <li>The length of the original packet in bytes.</li>
</ul>

<p>If the Ethernet frame type is not IP, ignore it and continue to analyze the next frame. If the frame contains an IP packet (read <code>/usr/include/net/ethernet.h</code> to fined out the value of the <em>type</em> field for IP), print the following:</p>

<ul>
  <li>IP packet length.</li>
  <li>Destination and source Ethernet addresses.</li>
  <li>Destination and source IP addresses in dotted-decimal notation.</li>
</ul>

<p>Remember the IP packet header is defined as follows in the file <em>/usr/include/netinet/ip.h</em>.</p>

<textarea rows = 25 cols = 80>
struct iphdr
  {
#if __BYTE_ORDER == __LITTLE_ENDIAN
    unsigned int ihl:4;
    unsigned int version:4;
#elif __BYTE_ORDER == __BIG_ENDIAN
    unsigned int version:4;
    unsigned int ihl:4;
#else
# error	"Please fix <bits/endian.h>"
#endif
    u_int8_t tos;
    u_int16_t tot_len;
    u_int16_t id;
    u_int16_t frag_off;
    u_int8_t ttl;
    u_int8_t protocol;
    u_int16_t check;
    u_int32_t saddr;
    u_int32_t daddr;
    /*The options start here. */
  };
</textarea>

<p>If the actual header file is a bit hard to read, here is a graph representation of it.</p>

<p><img src = "labs/ip-pkt-header.jpg" alt = "IP Packet Header"></p>

<p>Here is a sample output from a trace:</p>

<textarea rows = 45 cols = 80>
==== GLOBAL HEADER ====
magic number a1b2c3d4
major version 2
minor version 4
maximum captured packet length 65535
link layer type 1

=== packet count 0 ===
captured time Wed Dec 21 16:12:39 2005
bytes captured 42
length of packet 42
Ethernet type 0806 not IP, not processed.

=== packet count 1 ===
captured time Wed Dec 21 16:12:41 2005
bytes captured 64
length of packet 64
Ethernet type 0806 not IP, not processed.

=== packet count 2 ===
captured time Wed Dec 21 16:12:42 2005
bytes captured 77
length of packet 77
IP packet length 16128
dst addr = 0:c:41:a1:f5:da
src addr = 0:1:3:9c:ff:bd
type = 0800
src IP addr = 192.168.1.102
dest IP addr = 134.82.7.253

=== packet count 3 ===
captured time Wed Dec 21 16:12:42 2005
bytes captured 121
length of packet 121
IP packet length 27392
dst addr = 0:1:3:9c:ff:bd
src addr = 0:c:41:a1:f5:da
type = 0800
src IP addr = 134.82.7.253
dest IP addr = 192.168.1.102
</textarea>

<p>When you're done with this problem, you need to do:</p>

<font color =red><b>
<ul>
   <li>git add lab06</li>
   <li>git commit -m "Lab 6 completed"</li>
   <li>git push</li>
</ul>
</b></font>

<p>Congratulations, you have just finished lab 06!</p>

</body>
</html>
