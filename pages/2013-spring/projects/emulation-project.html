<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <title>CSCI 363 &mdash; Computer Networks -- Emulation Project</title>
  <meta http-equiv="content-type" content="text/html; charset=us-ascii">
  <link rel="stylesheet" type="text/css" href=
  "http://www.eg.bucknell.edu/~cs363/common-files/course.css">
  <base href="http://www.eg.bucknell.edu/~cs363/2013-spring/">
  <script type = "text/javascript" language = "JavaScript" src ="/~cs363/common-files/courseinfo.js">
</script>
</head>

<body>
<!-- header starts -->
<div id = "header">
<script type = "text/javascript" language = "JavaScript">
insertHTML('/~cs363/common-files/cs363header.html', 'header');
</script>
</div>
<!-- header ends -->

<h3>Project 2: Emulation: <em>Stop-and-go</em> Protocol</h3>

<p><b>Due: Friday April 26th, 2013</b></p>

<p>You are to write an emulation program to mimic the behavior of transmitting data through an unreliable medium. You will implement a basic version of <em>stop-and-go</em> protocol, a.k.a. <em>1-bit sliding window</em> protocol. Your program consists of two parts, a server and a client. The client sends a file of arbitrary length to the server, along with computed CRC. The server receives the data and checks for the integrity of the data by computing CRC using the same generating function as the client does. If the remainder is zero, the data is correct; otherwise the data is incorrect. Depending on the correctness of the data, the server sends an ack or a nack to the client. If a nack is received, the client will resend the data to the server.</p>

<p>In network software such as TCP/IP suite many implementation details have to be considered. In our project, we simplify the use cases to focus on some essential aspects. In particular, you are asked to provide a general API for the client of the format:</p>

<p><b>int send_data(char *host, char *data, int len)</b></p>

<p>and an API for the server</p>

<p><b>int recv_data(char *data, int len)</b></p>

<p>where the <em>host</em> is a symbolic name of the receiver such as <em>dana213-lnx-4</em>, <em>data</em> is the buffer for the data, and <em>len</em> is the length of the buffer. The behavior of the two functions is very similar to that of <em>read()/write()</em> pair or <em>sendto()/recvfrom()</em>.</p>

<p>The functions of <em>send_data()</em> and <em>recv_data()</em> can use UDP to send and receive data. If the size of the data to be sent is larger than the limit of UDP, the <em>send_data()</em> function is responsible for breaking the data into smaller segments and sending each to the receiver. For each data segment sent, the sender will wait for an acknowledgment from the receiver before next segment is sent. The function <em>send_data()</em> will not return until all segments of data are sent successfully. If a segment of data contains any error, the receiver sends a negative acknowledgment (nack) so that the sender can re-send the data segment.</p>

<p>If a piece of data is split into multiple segments, the receiver is responsible for reassembling the segments back to its original form using the sequence numbers.</p>

<p>You are asked to define a packet format, similar to that of UDP, which at minimum should include the following pieces of information.</p>
<textarea rows = 9 cols = 80>
struct pkthdr {
   uint8_t  type;          // type of the packet
   uint8_t  id;            // an id number used to identify the data sent
   uint16_t seq;           // sequence number of the packet
   uint16_t data_length;   // length of data in this packet, excluding header
   uint16_t checksum;      // CRC checksum
   char *   data           // pointer to the data
};
</textarea>
<p>The data type <code>uint8_t</code> is an 8-bit unsigned integer. If the type  has not been defined, you can define it as <code>unsigned char</code>. The data type <code>uint16_t</code> is a 16-bit unsigned integer. If the type has not been defined, you can define it as an <code>unsigned short</code>. The fields in the structure are explained as follows.</p>
<ul>
  <li> <em>type</em> specifies the type of the packet, data, acknowledgment, or negative acknowledgment.</li>

  <li> <em>id</em> is an identification number for the data. Multiple segments of the same data, e.g., one file, should share the same ID.</li>

  <li> <em>seq</em> is the sequence number of the packet. A piece of data may be split into multiple packets, the sequence number helps the receiver to reassemble the packets into the original data. The sequence number value of 0xFFFF indicates that this is the last packet of the data, which means the maximum sequence number that can be used is 0xFFFE.</li>

  <li> <em>data_length</em> is the data length in bytes in this packet, excluding the header.</li>

  <li> <em>checksum</em> is the CRC checksum computed in the same way as what you did in the lab.</li>

  <li> <em>data</em> is the pointer (address) of the data to be sent (or received).</em>
</ul>

<p>Test your programs using small data files first, that is, files that don't have to be split into multiple segments. Test also the cases where a data segment is corrupted, i.e., altering a byte before sending to the receiver but after computing its CRC. Once these cases work fine, try your programs on larger files. In particular, try to send the file <em>bode.pgm</em> which is a static image (photo). After receiver receives and reassembles the data, compare the two files to see if they are identical.</p>

<p>The file <em>bode.pgm</em> can be copied from Linux file system at</p>
<p><code>~cs363/Spring13/student/project/bode.pgm</code></p>

<p>Lastly when everything is working, add a timer to your client (the sender) so that when the timer expires before an ack is received, the send will resend the packet. Note that the receiver also needs to be revised so that if the same packet (<em>(id, seq)</em> pair are the same) is received, the later ones are dropped.</p>

<p>Demonstrate your program works by sending a small file such as Lincoln's <em>Gettysburg Address</em> and a large file such as the photo <em>bode.pgm</em> You can use the Linux <b>diff</b> command to compare the file sent and the file received by</p>

<p><b>diff file1 file2</b></p>

<p>Copy and paste the result into a text file <b>answer.txt</b>. Also in <b>answer.txt</b> please provide any instructions how to compile and run the programs and any thoughts you have for the project.</p>

<p>Once everything is finished, clean up the directory, and send everything to Gitlab.</p>

<p>Congratulations! You are done with the projects in this course!</p>
</body>
</html>
